package zetaclient

import (
	"github.com/cosmos/cosmos-sdk/client"
	clienttx "github.com/cosmos/cosmos-sdk/client/tx"
	"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/tx/signing"
	authsigning "github.com/cosmos/cosmos-sdk/x/auth/signing"
	keystone "github.com/regen-network/keystone/keys"
	"github.com/tendermint/tendermint/crypto"
)

// HsmSign Generates signature of msg using the key indexed by the label through the HSM defined in the config
func HsmSign(config string, msg []byte, label string) (signature []byte, err error) {
	keyring, err := keystone.NewPkcs11FromConfig(config)
	if err != nil {
		return
	}
	key, err := keyring.Key(label)
	if err != nil {
		return
	}
	signature, err = key.Sign(msg, nil)
	return
}

// GenerateKey This generates a new key using one of the supported algorithms and a label identifier through the HSM
func GenerateKey(label string, algorithm keystone.KeygenAlgorithm, config string) (*keystone.CryptoKey, error) {
	keyring, err := keystone.NewPkcs11FromConfig(config)
	if err != nil {
		return nil, err
	}
	key, err := keyring.NewKey(algorithm, label)
	return key, nil
}

// GetHSMAddress This address is generated by secp256k1 curve from cosmos sdk
func GetHSMAddress(config string, label string) (crypto.Address, *secp256k1.PubKey, error) {
	keyring, err := keystone.NewPkcs11FromConfig(config)
	if err != nil {
		return nil, nil, err
	}
	key, err := keyring.Key(label)
	if err != nil {
		return nil, nil, err
	}
	pubKey := key.PubKey()
	secp256k1key := pubKey.(*secp256k1.PubKey)
	return secp256k1key.Address(), secp256k1key, nil
}

// SignWithHSM signs a given tx with a named key.
// // This is adapted from github.com/cosmos/cosmos-sdk/client/tx Sign() function; Modified to use an HSM.
// // The resulting signature will be added to the transaction builder overwriting the previous
// // ones if overwrite=true (otherwise, the signature will be appended).
// // Signing a transaction with mutltiple signers in the DIRECT mode is not supprted and will
// // return an error.
// // An error is returned upon failure.
func SignWithHSM(
	txf clienttx.Factory,
	name string,
	txBuilder client.TxBuilder,
	overwriteSig bool,
	txConfig client.TxConfig,
	hsmConfig string,
	signMode signing.SignMode,
) error {
	address, pubKey, err := GetHSMAddress(hsmConfig, name)
	if err != nil {
		return err
	}

	signerData := authsigning.SignerData{
		ChainID:       txf.ChainID(),
		AccountNumber: txf.AccountNumber(),
		Sequence:      txf.Sequence(),
		PubKey:        pubKey,
		Address:       sdk.AccAddress(address).String(),
	}

	// For SIGN_MODE_DIRECT, calling SetSignatures calls setSignerInfos on
	// TxBuilder under the hood, and SignerInfos is needed to generated the
	// sign bytes. This is the reason for setting SetSignatures here, with a
	// nil signature.
	//
	// Note: this line is not needed for SIGN_MODE_LEGACY_AMINO, but putting it
	// also doesn't affect its generated sign bytes, so for code's simplicity
	// sake, we put it here.
	sigData := signing.SingleSignatureData{
		SignMode:  signMode,
		Signature: nil,
	}
	sig := signing.SignatureV2{
		PubKey:   pubKey,
		Data:     &sigData,
		Sequence: txf.Sequence(),
	}

	var prevSignatures []signing.SignatureV2
	if !overwriteSig {
		prevSignatures, err = txBuilder.GetTx().GetSignaturesV2()
		if err != nil {
			return err
		}
	}
	// Overwrite or append signer infos.
	var sigs []signing.SignatureV2
	if overwriteSig {
		sigs = []signing.SignatureV2{sig}
	} else {
		sigs = append(prevSignatures, sig) //nolint:gocritic
	}
	if err := txBuilder.SetSignatures(sigs...); err != nil {
		return err
	}

	// Generate the bytes to be signed.
	bytesToSign, err := txConfig.SignModeHandler().GetSignBytes(signMode, signerData, txBuilder.GetTx())
	if err != nil {
		return err
	}

	// Sign those bytes
	sigBytes, err := HsmSign(hsmConfig, bytesToSign, name)
	if err != nil {
		return err
	}

	// Construct the SignatureV2 struct
	sigData = signing.SingleSignatureData{
		SignMode:  signMode,
		Signature: sigBytes,
	}
	sig = signing.SignatureV2{
		PubKey:   pubKey,
		Data:     &sigData,
		Sequence: txf.Sequence(),
	}

	if overwriteSig {
		return txBuilder.SetSignatures(sig)
	}
	prevSignatures = append(prevSignatures, sig)
	return txBuilder.SetSignatures(prevSignatures...)
}
